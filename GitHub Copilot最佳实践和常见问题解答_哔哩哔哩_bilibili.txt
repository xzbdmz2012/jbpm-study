嗨，大家好！
这次主要是分享 GitHub Copilot 使用的最佳实践，以及解答在使用过程中经常会遇到的一些问题。
GitHub Copilot 本身是一个利用 AIGC 能力赋能开发者的新编程工具，这个工具学习成本低，大家看些介绍文档就可以自行使用。但在与同事沟通中，我们发现很多同事在使用过程中误解它的能力。今天这个视频的主要目的是想跟大家系统地介绍一下 GitHub Copilot，包括它的工作原理，这样大家在后续使用时就可以知道它的能力边界在哪里，以及如何使用它才能发挥最大功效，这是今天视频的最主要目的。
目前 GITHUB COBUSINESS 这个版本包含2个比较重要的功能：
GitHub Copilot：主要能力是补齐代码。
GitHub Copilot Chat：定位是在 IDE 里面的结对编程助手，相当于把 ChatGPT 内嵌在了 IDE 里边，使用体验在编程时会远超 ChatGPT。

下面先介绍 GitHub Copilot 的正确使用方式。Copilot 这个产品非常强大，但它也有自己的能力边界。有了这样的一个产品之后，我们开发者到底把这个 Copilot 定位成什么，才能让我们用起来更得心应手呢？其实我们可以从 Copilot 的名字入手，这个产品名称起得还是非常精准的。大家如果学过英文的构词法，应该知道 copilot 是一个合成词，co 是一起做某事的意思，pilot 有飞行员的意思，合在一起，它的本意是说一起开飞机的人，翻译成中文就是副驾。
我们可以想想在一个飞机上，副驾驶的责任跟机长的责任的区别。飞机能不能平安降落，始终都是机长的责任，副驾只是一个辅助，它可以提供建议，可以帮机长做一些各种各样琐碎的事情，但是最终的所有决策都是来自于机长。GitHub Copilot 的定位也是一样的，在我们 coding 的过程中，developer 才是这个 code 的最终执行者，Copilot 可以让我们日常的工作变得更好，就像副驾一样，可以给机长做很多事情，让机长的一些精力放在更重要的地方，这就是 Copilot 的定位。
这里再跟大家打个比方，我们可以把 Copilot 当成一匹马，这匹马是一匹老马识途的马，不是普通的马。我们把日常接触到的代码任务，可以抽象成需要把一批货物从 A 运到 B 去。那没有这匹马之前，我们需要人扛着这些货物，从 A 到 B 去走。中间路上如果遇到岔口，应该往哪个方向走，以前，人来干这个活的。
有了这匹马之后，就相当于不是人来拉着货物，而是有一匹马拉着货物，我们骑在马车上赶着这匹马往前走。因为从 A 到 B，这匹马已经走了无数遍了，因为这个马本身的编程任务其实就是代码，那这个 Copilot 的底层大语言模型，它已经从开源的代码里面学习到了非常多的从 A 到 B 的知识，就相当于这匹马从 A 到 B 已经走了无数遍，它知道这条路该怎么走。
我们现在就坐在这个马车上，赶着这匹马往前走。大多数情况下，这匹马知道路怎么走，但是我们当前做的 A 和 B 这个任务，跟开源世界里面的任务并不是完全一致的，就跟我们走路时一样，这条路可能最近翻修了，或者之前我们经过这条路的时候是夏天，现在是冬天，都会有不一样的条件变化。这种情况下，这匹马不一定每次都能准确识别出这条路来。
这时候我们坐在马车上干嘛呢，拿鞭子抽一下这匹马，如果它走到了一个岔路上，或者走的方向跟我们预期的不太一致，我们坐在马车上拿鞭子抽一下这匹马，让它回到正确的路上来，最终把这个货物快速地从 A 运到 B。这就是用运货的事情来说，我们 developer 在日常使用 GitHub Copilot 的时候，就相当于一个驾驶员，跟这个马车的关系就是这样。
通过这样的方式，您可以最大程度地发挥 GitHub Copilot 的能力。我们把它定位成这样，也是因为有一些技术限制。大家都知道大语言模型，GitHub Copilot 的后台也是 OpenAI 提供的大语言模型，这个大语言模型虽然能力很强，但它给我们的一些结果，或者 Copilot 给我们推荐的这些代码，并不能保证百分之百都是正确的，或者说是我们预期的。
这种情况下，始终需要我们的 developer 来做决策，我们要把从 A 到 B 的这条路想清楚，如果遇到困难，我们的预案是什么，这些东西我们都要想清楚，然后再让 Copilot 帮我们干具体的拉活、拉车的活儿，这就是 GitHub Copilot 的定位。有了这个定位之后，它最佳的工作方式，我们 developer 和 copilot 最佳的工作方式，就是我们来定具体的方向，然后由 Copilot 来干具体的活。
OK，在进入下面讲解功能之前，先跟大家聊一下 GitHub Copilot 的原理。因为我们都是 developer，如果我们在使用某一项技术的时候，知道这个技术的具体工作原理，知道它的能力边界，那后续我们在使用的时候就会更得心应手，就会知道哪些场景它非常适合，哪些场景它不一定能发挥作用，如果不能，我们应该怎么处理，我们心里就比较清楚了，所以我会把这个原理放到最前边。
这个原理其实也很重要，就是说我们在这个 IDE 里面，这个插件会始终盯着我们光标所停留的位置。如果我们触发了键盘上的某些事件，发现我们要录入新的字符了，可以是空格，可以是 tab 键，可以是回车，或者说你开始敲某个字符了都可以，这时候都会触发这个 plug in。
这个 plugin 会根据我们光标所停的位置，扫描我们的上文和下文，然后结合这个 plugin的能力，筛选出代码，自动构建提示词，把这个提示词发送给最终的大语言模型。大家注意一下，我们在生成建议之前的这些动作，不是简单地把我们当前的某一个固定的函数的一些代码发到后台去，而是有一个选择的过程。
它选择完这些代码片段之后，再结合 plugin里面预存的一些我们叫 prompt 的提示词库，根据不同的情况选择不同的提示词，组合起来形成最终的提示词，交给后端的大语言模型。大语言模型在收到这样的请求之后，生成对应的结果建议。它的基本工作原理就是我们会在 IDE 里面，根据光标所停留的位置，扫描上下文，然后结合后端的服务自动生成提示词。这个自动生成很重要，这就是它的基本工作原理。

另外一个 GitHub Copilot 使用时会经常被大家忽略的窗口，是 GitHub Copilot 的面板，这个面板其实也是非常重要的一个功能。因为正常我们在使用 GitHub Copilot 的时候，它给我们的建议一般是 1 - 3 个，少的话一个，多的话三个，会有 1 - 3 个建议，我们可以在这里面选，但很多时候我们发现 1 - 3 个建议里面，不是我们想要的，这时候怎么办呢，您可以 CTRL 加回车打开一个新的面板，在所有 ide 里面都有，这叫 GitHub Copilot 的面板，这个面板里面会提供十个，整整十个代码片段，然后去看一下哪个代码片段是您想要的，提供更多的选择，这是一个经常会被大家忽略的窗口。

然后 Copilot 如果想使用得比较好，用起来比较得心应手的话，也可以多熟悉一下它的快捷键，这里边我们也不再赘述了，如果大家感兴趣，可以去官方文档上找一下，他们的快捷键的一些使用技巧。

我们在使用 GitHub Copilot 的时候，其实很简单，因为它本身会自动根据我们的上文，就是鼠标所停留的位置，根据上文和下文生成对应的提示词，所以只要触发了键盘上的事件，它就会给我们提示对应的灰色部分叫 ghost text，就是幽灵文本，这里边也可以提供多个幽灵文本，如果觉得提示是对的，接受就好了，如果觉得不对，忽略就好了，这是它基本的使用方式，我们所有人都很熟悉，这里不再讲解。

这里我们也都知道，作为一个 developer，我们日常可以把工作分成三种类型。第一种是实现新的功能，就是要做的需求，可能要把所有需求都实现，这是新功能，这是我们经常会面临的工作。第二种工作类型是 fix bug，因为没有人能保证自己写的东西没有 bug，如果有 bug，我们就修复它，这也是我们日常的重要工作之一。第三种工作类型是做代码的重构，第四种是写文档，写测试用例。这四种基本上涵盖了我们所有 developer 日常的工作类型。等会我们看一下 GitHub Copilot 是怎样帮助我们做这些工作的。

刚才我们说过，它的核心能力，不是根据注释生成代码的，这个大家一定要注意，它的能力是根据我们光标所停留的位置的上下文，扫描所有的内容，然后生成代码的。

一个有良好编程习惯的人，先写注释后写代码，它会把注释当成高优先级的提示词片段，然后去帮助我们，但它绝对不是根据注释生成代码的。虽然注释有很强的权重，但是它的能力还是根据上下文，这是第一点要跟大家提的。

下一页

什么叫上下文，刚才我们也提到了，它的所有上文都算，除了当前编辑文件，还有邻近的 tab，邻近的这些文件也是算的，这个非常重要。我们发现打开不打开这些邻近的代码，对我们的代码接受率的影响是非常大的，一般会有 5 - 10 个点的区别，所以我们实际上说的上下文是指光标所在位置的上文和下文，以及已经打开的文件。

这里也跟大家说一下，如果我们打开的项目里面有几十上百个文件，如果没有打开，copilot是不知道的，只有打开了它才能知道上下文是什么，这也是 GitHub Copilot 的一个工作原理之一，它只会在我们已经打开或者正在编辑的文件里面起作用，不会主动去扫描磁盘上的文件，这是它的第二点要跟大家聊的。

大部分同学都有 ChatGPT 或者类似ai产品的使用经验，我们在使用 ChatGPT 的时候，如果把这段函数的描述直接丢到 ChatGPT 里边，它大概率也可以帮我们生成一些代码，但这个代码不太可能跟我们当前的项目匹配度这么高。
比如说在一个查询的代码里边，它知道这里面有一个叫 Scenario类，而且这个类里面包含了这么多的属性，它是怎么知道的呢，是因为在上下文里面包含了，所以我们刚才也提到了上文包含了上下文，包含了我们已经打开的文件，我们已经打开的文件里面包含了一个叫 Scenario类的，所以它在生成这些代码的时候，会参考我们的这些背景信息，再生成对应的代码，所以生成的这个代码是符合我们当前项目要求的，这是我们跟使用 ChatGPT 时最大的不同，它会自动把我们的背景信息告诉后端的大语言模型，这是刚才提到的一点。

下一页

GitHub Copilot 的核心能力是帮我们补齐文本，大家注意我的描述，它是补齐文本的，不是仅仅只能补齐代码，这个是符合我们编程时一些习惯的，我们在写代码的时候，不可能完全都写代码，可能会有一些注释，或者说是写一些 markdown 的说明文件，或者写一些脚本，这些都属于文本的范畴，也都属于跟我们研发工作相关的，所以 GitHub Copilot 的核心能力是帮我们补齐这些文本，这些文本可以是代码，也可以是注释。
下一页

我们公司要求保持一个驼峰命名法，那我就把这个函数名称改了，改成不是驼峰命名法，虽然说这个代码可以用，那我就改一下，改成这样的非驼峰命名法。新生成代码，它就变成了这个新的函数的格式了。
就是说 GitHub Copilot 在生成代码的时候，会根据我们的代码风格，做输出的格式的调整，它不光看我们上面的内容，也会看我们上面的内容

从这些文本的格式来看，对应的时候它在生成后，后续新的这个代码之后呢，就会参考我们上面的格式，去生成新的这个代码建议了啊。那这个也是非常重要的一点哈，就是这个是 Copilot 呢本身在使用的过程中，会去参考我们这些已经打开文件的这些背景信息，或者说我们已有的这些代码，它参考的不仅仅说是内容，也包括了我们的一些格式。那换句话说有了这样一个特性之后，那我们也就知道了，后续我们想让他去生成我们想要代码的时候呢，我们就可以把配套的一些代码打开，告诉他我的代码已经长成什么样了，我现在要干的事情是什么，那在这些背景信息下，你帮我做一个代码建议，那这时候很多时候他就有了这些这些消息之后呢，他就会给我们生成对应的我们想要的代码啊。

下一页

这个是我们做一个新产品功能的时候，我们也可以看一些其他的啊场景啊，比如说让他帮我们写单元测试啊。
那假如说我们这个产品代码已经写完了，我们要做的是这个单元测试的百分百覆盖啊。

DEMO

然后我们再来看下一个场景哈，那刚才我们介绍的是一个嗯很核心的一个场景，就是我们作为 develop，还是说日常要做的新功能的实现，那新工程，实际上其实并不会占我们特别大的一个比重，我们更多的一个研发任务呢是要修 bug 啊
DEMO

那不光说可以帮我们修 bug，也可以去做什么呢，我这次我就选中了这个代码，有没有什么可优化，就这里边呢

DEMO

，其实这个呃 GitHub Copilot 的一个定位是说 GitHub Copilot chat 的一个定位是说，它是我们绝对编程的一个助手，让您在编程的时候遇到的任何问题，都可以来问他，那比如说我想做优化，我没有什么思路，我可以问一下如何做优化这段代码，但是这里要注意一下哈，这个是 gpt跟 copilot的最大的一个，使用上最大的一个不同，copilot如果说您没有任何提示词的经验，引用 Copilot 也可以用，而且效果也不会太差，但是如果 gpt你在用的时候，没有任何提示词的经验，那它的效果就会诶，就是这个效果的上下限就会更大，但是它的方那个代码的这个就是推荐建议的，这个方差就会更大啊，是因为如果说您提示词的那个问的比较呃，符合提示词的这个规范，那它这个生存结果的质量就特别高，那如果说像我这样问啊，就如何优化这段代码，没头没尾的优化，总会有一个目标吧，你要做这种性能的优化，还是说是这个啊这个这个大并发下的优化函数，做什么样一个优化，你得给他一个目标，它才有优化的方向，但如果这个偏着问，那他们就会有有有这段就是还是 SQL 注入啊，然后搜数据读取等等等，给你一些边边角角的，那如果说我们进一步的问一些更好的啊，这样的一些一些问题，比如在大，你给他有这样的一个限定条件，然后有一些具体的一个一个优化目标，那这时候他再去做这种推荐的时候呢，就不太一样了啊，你可以看到在这个高并发下，他说你可以先用参参数优化查询，然后有个异步编程，然后使用连接池，然后对应的也把这个代码呢也给您提供出来了，


，他是个绝对编程的专家，而且不会累，不像我们人一样，然后工作一段三四个小时之后，大家总会疲乏的啊，总总会总会疲劳的，但是 cooper 不会，他会一直保持在线的一个状态，给我们做对应的一个提示，但是这也是一样的，您的这个问法是非常重要的啊，所以这时候我特别推荐大家有一定的呃呃学呃，积累一些提示词的这样的一个技巧啊，这个一定要做的。

那 copilot在使用的时候，你可以看到啊，您敲一下斜杠，它会有很多的这种快捷指令，那包含我们刚才的这种 fix 啊，就是实际上这个快捷指令指的是什么呢，这种 fix，它背后对应的是已经预制好的提示词啊，你你不想就是说帮我修这个，帮我修一下 bug 吧，其实你不想就敲这么多话的话，

你你不想就是说帮我修这个，帮我修一下 bug 吧，其实你不想敲这么多话的话，有个 fix 就好了，然后再选择这个代码，它会有一样的效果，比如解释、查找等等都是类似的。这里面这些快捷键其实包含了很多，每个 快捷键背后，都是一系列的提示词，这可以省掉我们很多的时间。
那在这里边，给大家进一步介绍一个新的功能，因为刚

然后在这里边再跟大家接着去看一下，因为刚才我们说的还是修 bug 和调试这块的内容，那很多时候我们拿到一个新的项目的时候，我们的任务是要重构它，这种也是有的，也是要重构它。那重构的时候就会带来一个问题，我得先读这个代码，因为我不知道大家的体验，然后我个人的体验是说嗯哪怕我自己写的代码，然后是半年前写的代码，然后我有半年没有看它了，那时候再让我去读，我自己写的代码很多时候我自己都读不懂，我自己当时写代码要花很多时间精力沉下心来去读。那如果说是别人的代码，那就会更难受。那 copilot 可以干什么呢？它可以帮我们去解释这个代码，

DEMO
比如说我在这儿可以全选所有的代码，然后说这段代码的功能是什么，你可以来问它。你看这时候我已经把注释删掉了，它会去读我们所有这个代码，然后去做个总结，告诉您最终的结果是什么。哎，这四个方法是这样的，但如果是这样的一个情况，那如果说我这个代码里面全是乱码，比如说这样的，它也依然可以正常去识别出来我们在这里可能要干什么。那我把这个先先关掉，再重新读一下，比如这两个有问题的，它也可以帮我们去梳理出来。就是啊，chat 也可以帮我们去读代码，这个例子其实跟大家说一下，它的 chat 可以帮我们读代码。那这样的话就简化了我们在做重构的时候去理解代码的时间。



这里面告诉我说，就是在我们去理解我们当前这个项目的时候，还有一个能力是什么呢？那这个能力也是新出的，然后跟大家说一下，那这个我们叫 workspace 的能力。workspace 的意思是什么呢？workspace 是一个特殊的命令，这个命令会让 GITHUB CHAT 去扫描我们当前的文件，然后形成一个临时的知识库，然后在这个知识库里边回答我们的问题。比如说我也是一样，我要重构这段代码了，我拿到这个项目之后，我发现这里面有几十个文件太多了，然后我也不是很熟这个项目，之前完全没有接触过，那我想让它帮我梳理一下，我就可以先问它这个项目是干嘛的，就可以这样问它。那它呢，你可以注意一下，我这块把所有的这个代码文件都关了，只是打开这个项目，然后去问它，问它的时候，它就会去扫描我当前所有的项目里面的文件，形成一个临时的知识库，然后再根据我的问题，从这个知识库里面把对应的答案拿出来，它是一个总结。那这样的话我就拿到一个新项目的时候，我可以先问一下这个项目到底是干什么的，然后它给我夸夸这样的一个回复，那我就问它，还可以再接着问它，那个数据库链接在哪，比如说我们在做的时候，我们知道这个情况了，那很多时候我们还会再接着去问，看到某一个代码片段的时候，我们大概知道了，我们通过第一个这样的方式知道这个项目是干嘛的了，然后分别是什么，然后我们打开这个文件呢，然后我们读了一下，发现诶这块这个定义我不知道在哪了，或者这个定义到底是什么含义，我们可以在这接着去问它，那个数据库连接在哪，可以接着再问它，那它呢会再接着去从这个知识库里面去看，然后给我们扫描这个代码，然后拿出拿到这个代码的一个答案，就是刚才这个问题的答案。OK，它正在转，那我们现在接着往下走。


那这里面跟大家说一下，copilot chat 本身，我们先说 copilot 本身的话，是没有 token 的这种限制的，我们它实际上不是说没有 token 的限制，而是说 copilot 在使用过程中，它在自动构建提示词的时候，会酌情地对我们已经有了这个代码片段做删减，比如说你打开了三个文件，每个文件都是上万行的代码，那 copilot 在里面帮您去生成代码推荐的时候，它不是机械地把这些所有代码都当成背景信息的，它会有一个抽样的过程，选择最有效的一些代码片段，然后再结合后端的提示词库，生成一个最终的提示词，它是有抽样的过程，所以你打开所有的文件，打开再多也不会影响 copilot 的使用，这是 copilot 的一个特点。但是 chat 不一样，chat 真的就是有这种对话的能力，它后端也是一个，但它有一个上下文的记忆，那有了上下文的记忆的话，就会带来一个问题，它 token 数是有限制的，那如果说它偶尔出错的时候，或者说返回了一些比较异常的结果，那你把它关了，再重新问一下也就好了，这种是经常会遇到的一些问题，跟大家做这样的一个解答。

那刚才也给大家看了一下 chat 的一些新的情况，当然除了这个之外的话，会这个 workspace 之外的话还会有，像这个 vs code，就是这个 IDE 本身的这样一些配置，或者说这个 terminal 的话，就是说你有一些命令行这个问题想问它，那比如说你如何打包成 docker 啊，类似于这样的问题，就涉及到这种问题的，你也可以通过这种 terminal 的方式在我们终端上去问它这样的一个结果，让它告诉我们我们应该是怎么来做打包的，这个告诉我们创建一个 docker file 的一个文件，然后它把我所有的这个内容，然后告诉我应该怎么做了，甚至说像我这个项目名称啊，它都给我生成的是符合我要求的，然后直接 copy 一下，然后把这个东西存成一个 docker file，然后去做个 build 就完成了我们这个操作，这里面会有一些其他快捷键，我这里就不多说了，不再展开了。

我们再回到 PPT 来看，那对我们刚才演示的 github copilot 的 chat 场景呢，做这样的一个总结，首先说它这里面有很多的这种场景可以去做，这些里面列出来的呢，列出来的都是我们已经验证过的，而且从客户里面收集到的反馈，都是非常好的一个效果，那大家可以在使用 chat 的时候多使用一下。然后我个人觉得，就是做这种技术方向的思路讨论特别有用，特别有用，但是用的时候呢也需要有一定的注意，因为 chat 跟 copilot 不一样，Chat 虽然说也可以帮我们去辅助地生成一些提示词，但是我们本身的这个问题的技巧就特别的重要，所以我们需要去积累一定的提示词，或者说要系统了解一下提示词，这里我也给大家做一个推荐，因为在目前这个趋势非常的明确，就是大语言模型一定会成为我们代码领域、写代码领域一个非常重要的助手，那既然说大语言模型已经是成为一个定式了，所以您一定要花一点时间去学习一下提示词，您在提示词工程上的这个系统了解所花的这一到两个小时，是您未来未来三到 5 年之内最有价值的这一到两个小时的投资了，这个特别特别推荐我们去了解一下。


然后在使用 github copilot 的时候，除了提示词之外的话，还会有一些其他要注意的地方，首先要理解一下 chat 的能力边界，chat 虽然说是这样的一个助手，而且能力也很好，现在的后端的引擎也是 GPT4，但是 chat 不是万能的，它所有的工作范围只是我们当前正在工作的任务，它没有办法超出我们工作的任务去做一些其他的，比如说我们给它丢一个图片，然后让它生成对应的代码，它没有这个能力，它只是通过问问题的方式，然后问问题的内容也是当前我们正在工作的这段代码，因为 cp for business 的工作本身，这个产品的定位就是在我们解决具体任务的时候提升我们单兵能力的，它不会涵盖更多，因为这个也受限于我们底层大语言模型的能力，所以它这个要注意它能力的边界。然后如果想用好的话，这个提示词是一定要的，然后有一个小技巧，就是给 AI 助手一个身份非常重要，有些时候您给它这个效果不太好，这个很多时候呢不是说他这个模型没这个能力，而是我们问的这个或者提示词的技巧不太够，那举个很简单的一个例子，比如说有这种提示词技巧，你告诉他你帮我做好这个代码优化，如果你优化不好的话，地球明天就爆炸了，虽然说你听着这句话呢非常的无厘头，但是它很有效果，所以类似的这种提示的技巧呢，你一定要去了解一下，然后这里边有一些常规的技巧，我就不再念了，这跟大家去聊一下。

OK，那在这里跟大家做一个总结，那 chat 的定位呢是说帮我们去梳理整体思路的，当然它有很多的能力，比如说它可以帮我们去写代码，也可以做代码修复等等都可以做，但是它的核心能力呢还是在我们思考的时候帮我们去梳理思路的，这个 chat 就相当于一个结对编程的专家，它不会累，也没有任何的情绪，你问它再初级的问题，它也不会有任何的生气的时候，而且它不会像我们人一样，工作一段时间之后就觉得很累，它不会，它不会一直在线，你有任何的问题都可以跟它做讨论，但是前提是什么呢，你有一定的提问的技巧，比如说我们想让它帮我们解决一个问题，我们在解决一个问题的时候，想让它帮我们梳理思路，那我们可以用到这种逻辑思维链的这样一个技术，然后通过提问，然后它一步步引导它，让它帮我们想出更详细的这样的一个方案，类似于这些技巧呢，其实啊如果有的话，那 chat 可以发挥它非常强的这样的一个作用出来。
是说 copilot 生成这个代码算谁的，算我们自己，这个毕竟 GITHUB copilot 只是一个工具，所有的生成代码都是我们，我们都是 owner，我们才有它的一个知识产权，那同样的，这个是个双刃剑，生成代码如果说有质量问题，也是属于我们自己的，因为它只是一个工具，生成代码呢，我们要它给我们提供建议的，最终决策是我们自己来做，那这个大家要注意一下。
OK，那今天的分享到这里，谢谢大家。